#' Pipleline For Integration Multiple PLSKO with Aggregate Knockoffs (AKO) Procedure
#'
#' This function implements the Aggregate Knockoffs (AKO) procedure from Nguyen et al. (2020)  with knockoff variables generated by PLSKO, to address the randomness from single-run knockoffs and improve the stablity. It generates multiple knockoff copies from PLSKO, computes feature importance statistics, aggregates p-values across knockoff realisations to control the false discovery rate. Compared to single-run knockoffs, AKO improved the average power with FDR control. The function is adapted from Tian et al. (2022).
#'
#' @import knockoff
#' @import foreach
#' @import doParallel
#' @import parallel
#' @import progressr
#'
#' @param X A numeric matrix or dataframe. The original predictor data matrix with \eqn{n} observations as rows and \eqn{p} variables as columns.
#' @param y A numeric vector of responses.
#' @param n_ko An integer specifying the number of knockoff copies to generate by PLSKO. Default is 25.
#' @param q A numeric value specifying the target false discovery rate (FDR). Default is 0.05.
#' @param offset An integer (0 or 1) specifying the offset in the empirical p-value calculation. Default is \eqn{0} (liberally control modified FDR with higher power). Other options include \eqn{1}, similar to "knockoffs+", yielding a slightly more conservative procedure that controls the FDR according to the usual definition.
#' @param w.method A character string specifying the method to compute feature importance statistics. Default is \code{"lasso.lcd"}. Other options include \code{"lasso.logistic"} for binary response variable, \code{"lasso.max.lambda"} for the maximum lambda value for the first entry on the path, and \code{"RF"} for random forest. See \code{\link{ko_filter}} or \code{\link{knockoff::knockoff.filter}} for more details.
#' @param gamma A numeric value between 0 and 1 for the quantile aggregation parameter. Default is 0.3.
#' @param parallel Logical value indicating whether to run the process in parallel. Default is \code{TRUE}.
#' @param ncores An integer specifying the number of cores to use for parallel processing. Default is NULL, which uses all available cores except one.
#' @param seed An integer to set the random seed for reproducibility. Default is 1.
#' @param ... Additional arguments passed to the \link[=plsko]{plsko} knockoff-generating function.
#'
#' @return A list of class 'AKO.result', containing:
#' \describe{
#'   \item{`s`}{A list of results from individual knockoff filters.}
#'   \item{`ako.s`}{The named vector of selected variables after aggregating knockoff results.}
#'   \item{`threshold`}{The FDR control threshold from AKO.}
#' }
#'
#' @examples
#'
#' # Example usage of ko.filter
#' set.seed(1)
#' X <- matrix(rnorm(100*10), 100, 10)
#' colnames(X) <- paste0("X", 1:10)
#'
#' # Example 1: continuous response without parallelisation
#' # randomly assign zero or one as coefficients to the variables
#' beta <- sample(c(0, 1), 10, replace = TRUE)
#' y <- X %*% beta + rnorm(100)
#'
#' # run the knockoff filter
#' start.time <- Sys.time()
#' result <- plsAKO2(X, y, q = 0.1, n_ko = 15, parallel = FALSE)
#' end.time <- Sys.time()
#' time.taken <- end.time - start.time
#' print(result)
#' time.taken
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result$s, function(x) x$selected)))
#'
#' # compare with the true coefficients
#' which(beta != 0)
#'
#' # Example 2: continuous response with parallelisation
#'
#' start.time <- Sys.time()
#' result <- plsAKO2(X, y, q = 0.1, n_ko = 15, parallel = T, ncores = 4)
#' end.time <- Sys.time()
#' time.taken <- end.time - start.time
#' print(result)
#' time.taken
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result$s, function(x) x$selected)))
#'
#' # compare with the true coefficients
#' which(beta != 0)
#'
#' # Example 3: binary response
#' y.bin <- rbinom(100, 1, 1/(1+ exp(-(X %*% beta)))) # convert to binary response
#' result.bin <- plsAKO(X, y.bin, n_ko = 15, q = 0.1, w.method = "lasso.logistic", parallel = T, ncores = 4)
#' print(result.bin)
#'
#' # check the frequency of selected variables from iterations of single-run knockoffs
#' table(unlist(lapply(result.bin$s, function(x) x$selected)))
#'
#' @references Yang G et al. PLSKO: a robust knockoff generator to control false discovery rate in omics variable selection. 2024:2024.08.06.606935.
#' @references Nguyen T-B et al. Aggregation of Multiple Knockoffs. Proceedings of the 37th International Conference on Machine Learning. PMLR, 2020, 7283â€“93.

#' @references Tian P et al. Grace-AKO: a novel and stable knockoff filter for variable selection incorporating gene network structures. BMC Bioinformatics 2022;23:478.

#'
#' @export
#'
plsAKO2 <- function(X, y, n_ko = 25,
                   q = 0.05, offset = 0, w.method = "lasso.lcd",
                   gamma = 0.3, parallel = T, ncores = NULL, seed = 1, ...){

  #Input type validation
  if(is.data.frame(X)){
    X.name = names(X)
    X = as.matrix(X)
  }else if (is.matrix(X)) {
    X.names = colnames(X)
  }else {
    stop('Input X must be a numeric matrix or data frame')
  }
  if (!is.numeric(X)) stop('Input X must be a numeric matrix or data frame')

  if (!is.factor(y) && !is.numeric(y)) {
    stop('Input y must be either of numeric or factor type')
  }
  if( is.numeric(y) ) y = as.vector(y)

  if(offset!=1 && offset!=0) {
    stop('Input offset must be either 0 or 1')
  }

  if (!w.method %in% c("lasso.lcd", "lasso.logistic", "lasso.max.lambda", "RF")) stop('Input w.method must be either "lasso.lcd", "lasso.logistic", "lasso.max.lambda" or "RF". Or check function "AKO_withW" for advanced customised W input')

  # Check if the number of observations in X is equal to the length of y
  stopifnot(length(y) == nrow(X))

  set.seed(seed)

  if(parallel){
    if (!requireNamespace('doParallel', quietly=T)) {
      warning('doParallel is not installed. Without parallelisation, the multiple knockoff sets will be slower to generate', call.=F,immediate.=T)
      parallel=F
    }
    if (!requireNamespace('foreach', quietly=T)) {
      warning('foreach is not installed. Without parallelisation, the multiple knockoff sets will be slower to generate', call.=F,immediate.=T)
      parallel=F
    }

    # Register cores for parallel computation
    if (parallel) {
      all_cores = parallel::detectCores(all.tests = TRUE, logical = TRUE)-1
      if(is.null(ncores)) ncores = all_cores # if not specified, use all cores except one
      if (ncores > ncores ) {
        warning(paste("The requested number of cores is not available. Using instead",all_cores,"cores"),immediate.=T)
        ncores = all_cores
      }
      if (ncores>1) {
        doParallel::registerDoParallel(cores=ncores)
        parallel = TRUE
      }
      else {
        parallel = FALSE
      }
    }
  }
    # Activate the progress bar
    handlers(global = TRUE)  # Enable global progress handlers
    pb <- progressr::progressor(along = 1:n_ko)  # Define progress bar

    with_progress({
    if(parallel){
      para.result <- foreach::foreach(i = 1:n_ko, .packages = 'knockoff') %dopar% {
        set.seed(seed + i)
        # Generate PLSKO knockoff
        ko = plsko(X, ...)

        # Calculate the apply knokcoff filter
        S <- ko_filter(X = X, Xk = ko, y = y, q = q, w.method = w.method, cores = 1)

        pvals = empirical_pval(S$statistic, offset = offset)

        res <- list(pvals = pvals, S = S)

        pb(message = sprintf("Running multiple knockoffs %d", i))  # Update the progress bar

        return(res)
      }
      doParallel::stopImplicitCluster()
      pvals = do.call(cbind, lapply(para.result, function(x) x$pvals))
      selected = lapply(para.result, function(x) x$S)

  } else {
    # Initialize matrix to store p-values from each knockoff iteration
    pvals = matrix(0, ncol(X), n_ko)
    selected <- list()
    for (i in 1:n_ko) {
      set.seed(seed + i)
      # Generate PLSKO knockoff
      ko = plsko(X, ...)

      # Calculate the apply knokcoff filter
      S <- ko_filter(X = X, Xk = ko, y = y, q = q, w.method = w.method)

      pvals[,i] = empirical_pval(S$statistic, offset = offset)
      selected[[i]] <- S

      pb(message = sprintf("Running multiple knockoffs %d", i))  # Update the progress bar
    }
  }
})
  aggregated_pval = apply(pvals, 1, quantile_aggregation, gamma=gamma)

  threshold = bhq_threshold(aggregated_pval, fdr=q)

  ako.s <- which(aggregated_pval <= threshold)
  names(ako.s) = X.names[ako.s]

  result <- structure(list(call = match.call(),
                           s = selected,
                           ako.s = ako.s,
                           threshold = threshold),
                      class = 'AKO.result')
  return(result)
}
